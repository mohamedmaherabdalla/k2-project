import {
  AlertTriangle,
  BarChart3,
  ChevronLeft,
  FileCode,
  FolderOpen,
  History,
  Loader2,
  Play,
  Settings,
  Shield,
  TerminalSquare,
  UserRound,
  Wrench,
} from "lucide-react";
import { useEffect, useMemo, useRef, useState, type FormEvent } from "react";
import { streamDynamicScan, type DynamicScanStreamEvent } from "../services/api";

type FileId = "vulnerable_bank.py" | "exploit.py" | "requirements.txt";
type PanelTab = "terminal" | "output";
type StepStatus = "pending" | "running" | "done";
type RuntimeState = "idle" | "loading" | "ready" | "error";
type AgentView = 0 | 1 | 2 | 3 | 4;
type AgentOutput = { label: string; lines: string[] };
type FindingBlock = {
  critical: string;
  explanation: string;
  location: string;
  roastSummary: string;
  recommendation: string;
};

type Props = {
  onBack: () => void;
};

type PyodideFs = {
  mkdir: (path: string) => void;
  writeFile: (path: string, content: string) => void;
  analyzePath: (path: string) => { exists: boolean };
};

type PyodideRuntime = {
  FS: PyodideFs;
  runPythonAsync: <T = unknown>(code: string) => Promise<T>;
  globals: {
    set: (name: string, value: unknown) => void;
    delete: (name: string) => void;
  };
};

declare global {
  interface Window {
    loadPyodide?: (options: { indexURL: string }) => Promise<PyodideRuntime>;
    __invariantPyodidePromise?: Promise<PyodideRuntime>;
  }
}

const PYODIDE_SCRIPT_URL = "https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js";
const PYODIDE_INDEX_URL = "https://cdn.jsdelivr.net/pyodide/v0.26.4/full/";
const PYODIDE_FALLBACK_SCRIPT_URL = "https://unpkg.com/pyodide@0.26.4/pyodide.js";
const PYODIDE_FALLBACK_INDEX_URL = "https://unpkg.com/pyodide@0.26.4/";

const PYODIDE_RUNNER = `
import io
import sys
import traceback

workspace = "/workspace"
if workspace not in sys.path:
    sys.path.insert(0, workspace)

stdout_capture = io.StringIO()
stderr_capture = io.StringIO()
old_stdout, old_stderr = sys.stdout, sys.stderr
sys.stdout, sys.stderr = stdout_capture, stderr_capture

globals_dict = {
    "__name__": "__main__",
    "__file__": __invariant_active_file
}

try:
    exec(__invariant_user_code, globals_dict)
except Exception:
    traceback.print_exc()
finally:
    sys.stdout, sys.stderr = old_stdout, old_stderr

stdout_capture.getvalue() + stderr_capture.getvalue()
`.trim();

const AGENT_STEPS = [
  "Agent 1 - Cartographer",
  "Agent 2 - Context Injector",
  "Agent 3 - Adversary",
  "Agent 4 - Roaster/Critic",
  "Agent 5 - Auditor",
] as const;

const EMPTY_AGENT_OUTPUTS: AgentOutput[] = AGENT_STEPS.map((label) => ({
  label,
  lines: ["No output yet. Run Scan Logic."],
}));

const KNOWN_FILE_IDS: readonly FileId[] = [
  "vulnerable_bank.py",
  "exploit.py",
  "requirements.txt",
];

const KEYWORDS = new Set([
  "and",
  "as",
  "async",
  "await",
  "class",
  "def",
  "elif",
  "else",
  "except",
  "False",
  "finally",
  "for",
  "from",
  "if",
  "import",
  "in",
  "is",
  "None",
  "not",
  "or",
  "pass",
  "raise",
  "return",
  "True",
  "try",
  "while",
  "with",
]);

const TOKEN_PATTERN =
  /(#.*$)|("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')|\b(?:and|as|async|await|class|def|elif|else|except|False|finally|for|from|if|import|in|is|None|not|or|pass|raise|return|True|try|while|with)\b|\b\d+(?:\.\d+)?\b|\b[a-zA-Z_]\w*(?=\()/g;

const INITIAL_FILES: Record<FileId, string> = {
  "vulnerable_bank.py": `import threading
import time


class BankAccount:
    def __init__(self, opening_balance):
        self.balance = opening_balance

    def withdraw(self, amount):
        if amount <= 0:
            return {"ok": False, "reason": "invalid amount"}

        if self.balance >= amount:
            current = self.balance
            time.sleep(0.08)
            self.balance = current - amount
            return {"ok": True, "new_balance": self.balance}

        return {"ok": False, "reason": "insufficient funds"}


account = BankAccount(1000)
`,
  "exploit.py": `# exploit.py will be auto-generated by Scan.
print("Run Scan Logic to generate dynamic exploit content.")
`,
  "requirements.txt": `flask==3.0.2
gunicorn==22.0.0
`,
};

export function LabSimulator({ onBack }: Props) {
  const [files, setFiles] = useState<Record<FileId, string>>(INITIAL_FILES);
  const [activeFile, setActiveFile] = useState<FileId>("vulnerable_bank.py");
  const [activePanel, setActivePanel] = useState<PanelTab>("terminal");
  const [scanRunning, setScanRunning] = useState(false);
  const [runRunning, setRunRunning] = useState(false);
  const [exploitUnlocked, setExploitUnlocked] = useState(false);
  const [fixApplied, setFixApplied] = useState(false);
  const [highlightedLinesByFile, setHighlightedLinesByFile] = useState<
    Partial<Record<FileId, number[]>>
  >({});
  const [terminalLines, setTerminalLines] = useState<string[]>([
    "$ python vulnerable_bank.py",
    "Type code and click Run to execute in-browser with Pyodide.",
    "Click Scan Logic to send current editor code to K2.",
  ]);
  const [debateLines, setDebateLines] = useState<string[]>([
    "Live agent debate will appear here after scan starts.",
  ]);
  const [agentOutputs, setAgentOutputs] = useState<AgentOutput[]>(EMPTY_AGENT_OUTPUTS);
  const [activeAgentView, setActiveAgentView] = useState<AgentView>(0);
  const [focusPromptInput, setFocusPromptInput] = useState("");
  const [queuedFocusPrompt, setQueuedFocusPrompt] = useState("");
  const [findingBlocks, setFindingBlocks] = useState<FindingBlock[]>([]);
  const [scanWarnings, setScanWarnings] = useState<string[]>([]);
  const [stepStatuses, setStepStatuses] = useState<StepStatus[]>([
    "pending",
    "pending",
    "pending",
    "pending",
    "pending",
  ]);
  const [outputText, setOutputText] = useState<string>(
    "Invariant Output is empty. Run Scan Logic to start analysis.",
  );
  const [apiState, setApiState] = useState<"idle" | "ok" | "down">("idle");
  const [runtimeState, setRuntimeState] = useState<RuntimeState>("idle");

  const codeLayerRef = useRef<HTMLPreElement | null>(null);
  const inputLayerRef = useRef<HTMLTextAreaElement | null>(null);
  const panelScrollRef = useRef<HTMLDivElement | null>(null);
  const pyodideRef = useRef<PyodideRuntime | null>(null);
  const scanControllerRef = useRef<AbortController | null>(null);

  const redLines = useMemo(
    () => new Set(highlightedLinesByFile[activeFile] ?? []),
    [activeFile, highlightedLinesByFile],
  );

  const highlightedCode = useMemo(
    () => renderCode(files[activeFile], redLines),
    [activeFile, files, redLines],
  );

  useEffect(() => {
    if (panelScrollRef.current) {
      panelScrollRef.current.scrollTop = panelScrollRef.current.scrollHeight;
    }
  }, [debateLines]);

  useEffect(
    () => () => {
      scanControllerRef.current?.abort();
    },
    [],
  );

  const pushDebate = (line: string) => {
    setDebateLines((prev) => [...prev, line]);
  };

  const pushAgentOutput = (agent: string, line: string) => {
    const index = resolveAgentIndex(agent);
    if (index === -1) {
      return;
    }

    setAgentOutputs((prev) =>
      prev.map((entry, idx) => {
        if (idx !== index) {
          return entry;
        }
        const nextLines =
          entry.lines.length === 1 && entry.lines[0] === "No output yet. Run Scan Logic."
            ? [line]
            : [...entry.lines, line];
        return { ...entry, lines: nextLines };
      }),
    );
  };

  const pushTerminal = (line: string) => {
    setTerminalLines((prev) => [...prev, line]);
  };

  const pushTerminalBlock = (block: string) => {
    const lines = block.replace(/\r/g, "").split("\n");
    const normalized = lines.filter((line, index) => !(line === "" && index === lines.length - 1));
    setTerminalLines((prev) => [...prev, ...normalized]);
  };

  const setStepStatusForAgent = (agent: string, status: StepStatus) => {
    const index = resolveAgentIndex(agent);
    if (index === -1) {
      return;
    }
    setStepStatuses((prev) => prev.map((entry, idx) => (idx === index ? status : entry)));
  };

  const handleFileClick = (fileId: FileId) => {
    if (fileId === "exploit.py" && !exploitUnlocked) {
      return;
    }
    setActiveFile(fileId);
  };

  const handleCodeChange = (value: string) => {
    setFixApplied(false);
    setFiles((prev) => ({ ...prev, [activeFile]: value }));
  };

  const syncScroll = () => {
    if (!codeLayerRef.current || !inputLayerRef.current) {
      return;
    }
    codeLayerRef.current.scrollTop = inputLayerRef.current.scrollTop;
    codeLayerRef.current.scrollLeft = inputLayerRef.current.scrollLeft;
  };

  const ensurePyodideReady = async (): Promise<PyodideRuntime> => {
    if (pyodideRef.current) {
      return pyodideRef.current;
    }

    setRuntimeState("loading");

    if (!window.loadPyodide) {
      try {
        await injectScript(PYODIDE_SCRIPT_URL);
      } catch {
        await injectScript(PYODIDE_FALLBACK_SCRIPT_URL);
      }
    }

    if (!window.__invariantPyodidePromise) {
      if (!window.loadPyodide) {
        throw new Error("Pyodide loader did not initialize.");
      }
      try {
        window.__invariantPyodidePromise = window.loadPyodide({
          indexURL: PYODIDE_INDEX_URL,
        });
        await window.__invariantPyodidePromise;
      } catch {
        window.__invariantPyodidePromise = window.loadPyodide({
          indexURL: PYODIDE_FALLBACK_INDEX_URL,
        });
      }
    }

    const runtime = await window.__invariantPyodidePromise;
    ensureWorkspace(runtime);
    pyodideRef.current = runtime;
    setRuntimeState("ready");
    return runtime;
  };

  const handleRunCode = async () => {
    if (runRunning) {
      return;
    }

    if (!activeFile.endsWith(".py")) {
      pushTerminal("Only .py files can be executed in this runtime.");
      return;
    }

    setRunRunning(true);
    setActivePanel("terminal");
    pushTerminal(`$ python ${activeFile}`);

    try {
      const runtime = await ensurePyodideReady();
      syncWorkspace(runtime, files);

      runtime.globals.set("__invariant_user_code", files[activeFile]);
      runtime.globals.set("__invariant_active_file", activeFile);

      const output = await runtime.runPythonAsync<string>(PYODIDE_RUNNER);
      if (typeof output === "string" && output.trim()) {
        pushTerminalBlock(output.trimEnd());
      } else {
        pushTerminal("[program exited with no output]");
      }
    } catch (error) {
      setRuntimeState("error");
      pushTerminal(`Error: ${asErrorMessage(error)}`);
    } finally {
      try {
        pyodideRef.current?.globals.delete("__invariant_user_code");
        pyodideRef.current?.globals.delete("__invariant_active_file");
      } catch {
        // no-op cleanup path
      }
      setRunRunning(false);
    }
  };

  const handleQueueFocusPrompt = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const value = focusPromptInput.trim();
    if (!value) {
      return;
    }
    setQueuedFocusPrompt(value);
    setFocusPromptInput("");
    pushDebate(`[Operator] Focus queued for next scan: ${value}`);
    pushTerminal(`Focus prompt queued: "${value}"`);
  };

  const applyScanTextResult = (analysisText: string, sourceFile: FileId) => {
    const parsedAgentOutputs = parseAgentOutputs(analysisText);
    if (parsedAgentOutputs) {
      setAgentOutputs((prev) =>
        prev.map((entry, index) => ({
          ...entry,
          lines:
            parsedAgentOutputs[index] && parsedAgentOutputs[index].length > 0
              ? parsedAgentOutputs[index]
              : entry.lines,
        })),
      );
    }

    const parsedFindings = parseFindingBlocks(analysisText);
    setFindingBlocks(parsedFindings);

    const highlights = extractHighlights(analysisText, sourceFile);
    setHighlightedLinesByFile(highlights);

    const exploit = extractExploitCode(analysisText);
    if (exploit) {
      setFiles((prev) => ({ ...prev, "exploit.py": withTrailingNewline(exploit) }));
      setExploitUnlocked(true);
      pushTerminal("exploit.py generated from analysis output.");
    }
  };

  const handleScanLogic = async () => {
    if (scanRunning) {
      return;
    }

    const controller = new AbortController();
    scanControllerRef.current?.abort();
    scanControllerRef.current = controller;

    setScanRunning(true);
    setActivePanel("output");
    setFixApplied(false);
    setActiveAgentView(0);
    setOutputText("");
    setDebateLines([]);
    setAgentOutputs(
      AGENT_STEPS.map((label) => ({
        label,
        lines: ["Waiting for output..."],
      })),
    );
    setFindingBlocks([]);
    setScanWarnings([]);
    setStepStatuses(["running", "pending", "pending", "pending", "pending"]);
    setHighlightedLinesByFile({});
    pushTerminal(`$ invariant scan ${activeFile}`);
    pushTerminal("Invariant AI Reasoning...");
    pushDebate("Scan started. Waiting for backend stream...");
    if (queuedFocusPrompt) {
      pushTerminal(`Using operator focus: ${queuedFocusPrompt}`);
    }

    let combinedText = "";

    try {
      await streamDynamicScan(
        {
          code: files[activeFile],
          filename: activeFile,
          focusPrompt: queuedFocusPrompt || undefined,
        },
        {
          signal: controller.signal,
          onEvent: (event) => {
            handleScanEvent(event, {
              onToken: (chunk) => {
                setApiState("ok");
                combinedText += chunk;
                setOutputText((prev) => prev + chunk);
              },
              onDebate: pushDebate,
              onAgentLog: pushAgentOutput,
              onStep: setStepStatusForAgent,
              onWarning: (message) => setScanWarnings((prev) => [...prev, message]),
              onError: (message) => {
                setApiState("down");
                setScanWarnings((prev) => [...prev, message]);
              },
              onDone: (analysisText) => {
                if (analysisText.trim()) {
                  combinedText = analysisText;
                  setOutputText(analysisText);
                }
              },
            });
          },
        },
      );

      const finalText = combinedText.trim();
      if (!finalText) {
        pushDebate("Scan completed with empty response payload.");
        pushTerminal("Scan complete: no response content.");
      } else {
        applyScanTextResult(finalText, activeFile);

        const criticalCount = countCriticalBlocks(finalText);
        pushTerminal(`Scan complete: ${criticalCount} critical block(s) reported.`);
      }

      if (queuedFocusPrompt) {
        setQueuedFocusPrompt("");
      }
    } catch (error) {
      if (controller.signal.aborted) {
        pushTerminal("Scan aborted.");
      } else {
        setApiState("down");
        const reason = asErrorMessage(error);
        const fallbackReport = buildClientFallbackReport(files[activeFile], activeFile, reason);

        setOutputText(fallbackReport);
        setScanWarnings((prev) => [
          ...prev,
          `Backend unavailable. Local fallback mode used. Reason: ${reason}`,
        ]);
        pushDebate(`[Client Fallback] ${reason}`);
        pushTerminal("Scan backend unavailable. Switched to local fallback mode.");

        setStepStatuses(["done", "done", "done", "done", "done"]);
        applyScanTextResult(fallbackReport, activeFile);

        const fallbackCriticals = countCriticalBlocks(fallbackReport);
        pushTerminal(`Fallback scan complete: ${fallbackCriticals} critical block(s) reported.`);
      }
    } finally {
      setScanRunning(false);
      scanControllerRef.current = null;
    }
  };

  const handleApplyFix = () => {
    if (activeFile !== "vulnerable_bank.py") {
      pushTerminal("Auto-fix is only wired for vulnerable_bank.py demo pattern.");
      return;
    }

    setFiles((prev) => {
      let patched = prev["vulnerable_bank.py"];

      if (!patched.includes("self._lock = threading.Lock()")) {
        patched = patched.replace(
          "        self.balance = opening_balance",
          "        self.balance = opening_balance\n        self._lock = threading.Lock()",
        );
      }

      patched = patched.replace(
        "        if self.balance >= amount:\n            current = self.balance\n            time.sleep(0.08)\n            self.balance = current - amount\n            return {\"ok\": True, \"new_balance\": self.balance}\n",
        "        with self._lock:\n            if self.balance >= amount:\n                current = self.balance\n                time.sleep(0.08)\n                self.balance = current - amount\n                return {\"ok\": True, \"new_balance\": self.balance}\n",
      );

      return {
        ...prev,
        "vulnerable_bank.py": patched,
      };
    });

    setHighlightStateForFile("vulnerable_bank.py", []);
    setFixApplied(true);
    pushTerminal("Patch applied: lock guard added around withdrawal critical section.");
    pushDebate("Patch operation applied in editor. Re-run Scan Logic to verify remediation.");
  };

  const runtimeLabel =
    runtimeState === "ready"
      ? "Runtime Ready"
      : runtimeState === "loading"
        ? "Runtime Loading"
        : runtimeState === "error"
          ? "Runtime Error"
          : "Runtime Idle";

  return (
    <div className="lab-shell">
      <aside className="lab-rail">
        <div className="lab-rail-logo">
          <TerminalSquare size={20} />
        </div>
        <div className="lab-rail-nav">
          <button className="lab-rail-btn active" title="Explorer">
            <FolderOpen size={18} />
          </button>
          <button className="lab-rail-btn" title="Security">
            <Shield size={18} />
          </button>
          <button className="lab-rail-btn" title="Metrics">
            <BarChart3 size={18} />
          </button>
          <button className="lab-rail-btn" title="History">
            <History size={18} />
          </button>
        </div>
        <div className="lab-rail-foot">
          <button className="lab-rail-btn" title="Settings">
            <Settings size={18} />
          </button>
          <div className="lab-avatar">
            <UserRound size={16} />
          </div>
        </div>
      </aside>

      <section className="lab-center">
        <header className="lab-topbar">
          <div className="lab-file-chip">
            <FileCode size={15} />
            <span>{activeFile}</span>
          </div>
          <div className="lab-topbar-actions">
            <button className="lab-back-btn" onClick={onBack}>
              <ChevronLeft size={14} />
              Back
            </button>
            <span className={`lab-runtime-pill lab-runtime-pill-${runtimeState}`}>{runtimeLabel}</span>
            <span className={`lab-api-pill lab-api-pill-${apiState}`}>
              API {apiState === "ok" ? "Online" : apiState === "down" ? "Offline" : "Unknown"}
            </span>
            <button className="lab-run-btn" onClick={handleRunCode} disabled={runRunning}>
              {runRunning ? (
                <>
                  <Loader2 size={14} className="spin-loop" />
                  Running...
                </>
              ) : (
                <>
                  <Play size={13} />
                  Run
                </>
              )}
            </button>
            <button className="lab-scan-btn" onClick={handleScanLogic} disabled={scanRunning}>
              {scanRunning ? (
                <>
                  <Loader2 size={14} className="spin-loop" />
                  Invariant AI Reasoning...
                </>
              ) : (
                "Scan Logic"
              )}
            </button>
          </div>
        </header>

        <div className="lab-workbench">
          <aside className="lab-explorer">
            <div className="lab-explorer-title">Explorer</div>
            <div className="lab-group-title">workspace</div>
            <button
              className={`lab-file-row ${activeFile === "vulnerable_bank.py" ? "active" : ""}`}
              onClick={() => handleFileClick("vulnerable_bank.py")}
            >
              <span className="lab-file-badge">py</span>
              vulnerable_bank.py
            </button>
            <button
              className={`lab-file-row ${activeFile === "exploit.py" ? "active" : ""} ${!exploitUnlocked ? "disabled" : ""}`}
              onClick={() => handleFileClick("exploit.py")}
              title={!exploitUnlocked ? "Locked until scan completes" : "Open exploit script"}
            >
              <span className="lab-file-badge">py</span>
              exploit.py
            </button>
            <button
              className={`lab-file-row ${activeFile === "requirements.txt" ? "active" : ""}`}
              onClick={() => handleFileClick("requirements.txt")}
            >
              <span className="lab-file-badge txt">txt</span>
              requirements.txt
            </button>
          </aside>

          <section className="lab-editor-column">
            <div className="lab-editor-surface">
              <pre
                ref={codeLayerRef}
                className="lab-code-layer"
                dangerouslySetInnerHTML={{ __html: highlightedCode }}
              />
              <textarea
                ref={inputLayerRef}
                className="lab-input-layer"
                value={files[activeFile]}
                onChange={(event) => handleCodeChange(event.target.value)}
                onScroll={syncScroll}
                spellCheck={false}
              />
            </div>

            <section className="lab-bottom-panel">
              <div className="lab-panel-tabs">
                <button
                  className={activePanel === "terminal" ? "lab-panel-tab active" : "lab-panel-tab"}
                  onClick={() => setActivePanel("terminal")}
                >
                  Terminal
                </button>
                <button
                  className={activePanel === "output" ? "lab-panel-tab active" : "lab-panel-tab"}
                  onClick={() => setActivePanel("output")}
                >
                  Invariant Output
                </button>
              </div>
              <div className="lab-panel-content">
                {activePanel === "terminal" ? (
                  <pre className="lab-terminal-output">
                    {terminalLines.map((line, idx) => (
                      <div key={`${idx}-${line}`}>{line}</div>
                    ))}
                  </pre>
                ) : (
                  <div className="lab-output-stack">
                    {scanWarnings.length > 0 ? (
                      <div className="lab-warning-banner">
                        {scanWarnings[scanWarnings.length - 1]}
                      </div>
                    ) : null}
                    {findingBlocks.length > 0 ? (
                      <div className="lab-findings-grid">
                        {findingBlocks.map((finding, idx) => (
                          <div className="lab-finding-card" key={`${idx}-${finding.critical}`}>
                            <div className="lab-finding-title">{finding.critical}</div>
                            <div className="lab-finding-line">{finding.explanation}</div>
                            <div className="lab-finding-line">LOCATION: {finding.location}</div>
                            <div className="lab-finding-line">
                              ROAST SUMMARY: {finding.roastSummary}
                            </div>
                            <div className="lab-finding-line">
                              RECOMMENDATION: {finding.recommendation}
                            </div>
                          </div>
                        ))}
                      </div>
                    ) : null}
                    <pre className="lab-invariant-output">
                      {outputText}
                      {scanRunning ? <span className="cursor">â–‹</span> : null}
                    </pre>
                  </div>
                )}
              </div>
            </section>
          </section>
        </div>
      </section>

      <aside className="lab-right-panel">
        <header className="lab-right-header">
          <h2>Invariant Logic Core v2</h2>
          <div className="lab-live-badge">
            <span className="dot" />
            Live
          </div>
        </header>

        <div className="lab-right-body" ref={panelScrollRef}>
          <div className="lab-step-list">
            {AGENT_STEPS.map((name, index) => (
              <div className="lab-step-item" key={name}>
                <div className={`lab-step-dot ${stepStatuses[index]}`} />
                <div className="lab-step-content">
                  <div className="lab-step-title">{name}</div>
                  <div className="lab-step-status">
                    {stepStatuses[index] === "done"
                      ? "completed"
                      : stepStatuses[index] === "running"
                        ? "running"
                        : "pending"}
                  </div>
                </div>
              </div>
            ))}
          </div>

          <div className="lab-agent-output-card">
            <div className="lab-agent-tabs">
              {agentOutputs.map((agent, index) => (
                <button
                  key={agent.label}
                  className={`lab-agent-tab ${activeAgentView === index ? "active" : ""}`}
                  onClick={() => setActiveAgentView(index as AgentView)}
                >
                  A{index + 1}
                </button>
              ))}
            </div>
            <div className="lab-agent-title">{agentOutputs[activeAgentView].label}</div>
            <div className="lab-agent-lines">
              {agentOutputs[activeAgentView].lines.map((line, idx) => (
                <div key={`${activeAgentView}-${idx}-${line}`} className="lab-agent-line">
                  {line}
                </div>
              ))}
            </div>
          </div>

          <div className="lab-debate-log">
            {debateLines.map((line, idx) => (
              <div key={`${idx}-${line}`} className="lab-debate-line">
                {line}
              </div>
            ))}
          </div>
        </div>

        <div className="lab-insight-card">
          <div className="lab-insight-head">
            <div className="lab-insight-title">
              <AlertTriangle size={16} />
              Logic Violation Detected
            </div>
            <span className="lab-critical-pill">Critical</span>
          </div>
          <p className="lab-insight-copy">
            Scan output is now dynamic: findings, locations, and exploit code are generated from the
            current editor content, not a hardcoded template.
          </p>
          <button className="lab-fix-btn" onClick={handleApplyFix}>
            <Wrench size={14} />
            {fixApplied ? "Fix Applied" : "Apply Fix"}
          </button>
          <form className="lab-chatbar" onSubmit={handleQueueFocusPrompt}>
            <input
              value={focusPromptInput}
              onChange={(event) => setFocusPromptInput(event.target.value)}
              placeholder="Ask agents what to focus on in the next scan..."
            />
            <button type="submit">Queue</button>
          </form>
          {queuedFocusPrompt ? (
            <div className="lab-queued-note">Queued: {queuedFocusPrompt}</div>
          ) : null}
        </div>
      </aside>
    </div>
  );

  function setHighlightStateForFile(fileId: FileId, lines: number[]) {
    setHighlightedLinesByFile((prev) => ({ ...prev, [fileId]: lines }));
  }
}

function handleScanEvent(
  event: DynamicScanStreamEvent,
  handlers: {
    onToken: (chunk: string) => void;
    onDebate: (line: string) => void;
    onAgentLog: (agent: string, line: string) => void;
    onStep: (agent: string, status: StepStatus) => void;
    onWarning: (message: string) => void;
    onError: (message: string) => void;
    onDone: (analysisText: string) => void;
  },
) {
  if (event.type === "run_start") {
    handlers.onDebate(`Run ${event.run_id} started for ${event.filename}.`);
    return;
  }

  if (event.type === "log") {
    handlers.onDebate(`[${event.agent}] ${event.message}`);
    handlers.onAgentLog(event.agent, event.message);
    handlers.onStep(event.agent, "running");
    return;
  }

  if (event.type === "agent_status") {
    handlers.onStep(event.agent, event.status === "done" ? "done" : "running");
    return;
  }

  if (event.type === "token") {
    handlers.onToken(event.content);
    return;
  }

  if (event.type === "error") {
    handlers.onDebate(`[Pipeline Warning] ${event.message}`);
    handlers.onWarning(event.message);
    if (event.message.toLowerCase().includes("k2") || event.message.toLowerCase().includes("http")) {
      handlers.onError(event.message);
    }
    return;
  }

  if (event.type === "done") {
    handlers.onDone(event.analysis_text ?? "");
  }
}

async function injectScript(src: string): Promise<void> {
  const existing = document.querySelector<HTMLScriptElement>(`script[src="${src}"]`);
  if (existing) {
    if (existing.dataset.loaded === "true") {
      return;
    }
    await new Promise<void>((resolve, reject) => {
      existing.addEventListener("load", () => resolve(), { once: true });
      existing.addEventListener("error", () => reject(new Error("Failed to load runtime script.")), {
        once: true,
      });
    });
    return;
  }

  await new Promise<void>((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;
    script.async = true;
    script.addEventListener(
      "load",
      () => {
        script.dataset.loaded = "true";
        resolve();
      },
      { once: true },
    );
    script.addEventListener("error", () => reject(new Error("Failed to load runtime script.")), {
      once: true,
    });
    document.head.appendChild(script);
  });
}

function ensureWorkspace(runtime: PyodideRuntime) {
  const exists = runtime.FS.analyzePath("/workspace").exists;
  if (!exists) {
    runtime.FS.mkdir("/workspace");
  }
}

function syncWorkspace(runtime: PyodideRuntime, files: Record<FileId, string>) {
  ensureWorkspace(runtime);
  for (const [path, content] of Object.entries(files)) {
    if (path.endsWith(".py")) {
      runtime.FS.writeFile(`/workspace/${path}`, content);
    }
  }
}

function countCriticalBlocks(text: string): number {
  const blocks = text.match(/CRITICAL:/gi);
  return blocks ? blocks.length : 0;
}

function buildClientFallbackReport(code: string, filename: FileId, reason: string): string {
  const lower = code.toLowerCase();
  const lines = code.split("\n");

  let critical = "No Critical Logic Flaw";
  let explanation =
    "No critical exploit path was proven in browser fallback mode for the current snippet.";
  let location = `${filename}:1`;
  let roastSummary =
    "Fallback mode retained only high-signal patterns and rejected non-provable weak hypotheses.";
  let recommendation =
    "Run backend with K2 enabled for full agent reasoning and exploit synthesis.";
  let exploitCode = "print('No exploit generated in local fallback mode')";

  const raceLine = findLineByNeedles(lines, ["thread", "sleep(", "lock"]);
  const authLine = findLineByNeedles(lines, ["auth", "permission", "is_admin", "token"]);
  const idLine = findLineByNeedles(lines, ["user_id", "account_id", "owner_id"]);

  if (raceLine && lower.includes("thread")) {
    critical = "Race Condition Flaw";
    explanation =
      "Concurrent execution can violate account invariants and produce inconsistent balances.";
    location = `${filename}:${raceLine}`;
    roastSummary =
      "Retained because shared state appears mutable without a proven atomic guard around updates.";
    recommendation =
      "Protect the critical section using locks or transactions and add concurrent regression tests.";
    exploitCode = [
      "import threading",
      "from target import shared_action",
      "",
      "def worker():",
      "    print(shared_action())",
      "",
      "threads = [threading.Thread(target=worker) for _ in range(2)]",
      "for t in threads: t.start()",
      "for t in threads: t.join()",
    ].join("\n");
  } else if (authLine && idLine) {
    critical = "Object-Level Authorization Bypass";
    explanation =
      "Identifier-based lookups without strict ownership validation can leak protected records.";
    location = `${filename}:${idLine}`;
    roastSummary =
      "Retained because attacker-controlled object identifiers can cross tenant boundaries.";
    recommendation =
      "Bind every object access to authenticated subject ownership and deny tenant mismatch.";
    exploitCode = [
      "import requests",
      "",
      "for victim_id in range(1, 5):",
      "    r = requests.get(f'http://localhost/resource/{victim_id}', headers={'Authorization': 'Bearer token'})",
      "    print(victim_id, r.status_code, r.text[:80])",
    ].join("\n");
  }

  return [
    "[DEBATE]",
    "AGENT 1: Control-flow and state transitions were mapped from the editor code.",
    "AGENT 2: Business invariants were inferred from state and authorization signals.",
    "AGENT 3: Potential bypass paths were tested for attacker-controlled inputs.",
    "AGENT 4: Weak claims were rejected unless exploitability remained concrete.",
    "AGENT 5: Final report assembled in strict critical format.",
    "",
    "[FINAL]",
    `CRITICAL: ${critical}`,
    `EXPLANATION: ${explanation}`,
    `LOCATION: ${location}`,
    `ROAST SUMMARY: ${roastSummary}`,
    `RECOMMENDATION: ${recommendation}`,
    "",
    "[EXPLOIT]",
    "```python",
    exploitCode,
    "```",
    "",
    `NOTE: Fallback mode activated because backend stream failed: ${reason}`,
  ].join("\n");
}

function parseAgentOutputs(text: string): string[][] | null {
  const outputs: string[][] = AGENT_STEPS.map(() => []);
  const lines = text.split("\n");

  for (const line of lines) {
    const match = line.match(/^\s*AGENT\s*([1-5])\s*:\s*(.+)\s*$/i);
    if (!match) {
      continue;
    }
    const index = Number(match[1]) - 1;
    if (index < 0 || index > 4) {
      continue;
    }
    outputs[index].push(match[2].trim());
  }

  return outputs.some((list) => list.length > 0) ? outputs : null;
}

function parseFindingBlocks(text: string): FindingBlock[] {
  const criticals = [...text.matchAll(/CRITICAL:\s*(.+)/gi)].map((match) => match[1]?.trim() ?? "");
  const explanations = [...text.matchAll(/EXPLANATION:\s*(.+)/gi)].map(
    (match) => match[1]?.trim() ?? "",
  );
  const locations = [...text.matchAll(/LOCATION:\s*(.+)/gi)].map((match) => match[1]?.trim() ?? "");
  const roastSummaries = [...text.matchAll(/ROAST SUMMARY:\s*(.+)/gi)].map(
    (match) => match[1]?.trim() ?? "",
  );
  const recommendations = [...text.matchAll(/RECOMMENDATION:\s*(.+)/gi)].map(
    (match) => match[1]?.trim() ?? "",
  );

  const total = Math.max(
    criticals.length,
    explanations.length,
    locations.length,
    roastSummaries.length,
    recommendations.length,
  );
  const findings: FindingBlock[] = [];
  for (let index = 0; index < total; index += 1) {
    findings.push({
      critical: criticals[index] ?? "Unspecified Critical",
      explanation: explanations[index] ?? "No explanation provided.",
      location: locations[index] ?? "unknown:1",
      roastSummary: roastSummaries[index] ?? "No roast summary provided.",
      recommendation: recommendations[index] ?? "No recommendation provided.",
    });
  }
  return findings;
}

function extractExploitCode(text: string): string | null {
  const match = text.match(/```python\s*([\s\S]*?)```/i);
  if (!match || !match[1]) {
    return null;
  }
  return match[1].trim();
}

function extractHighlights(
  text: string,
  fallbackFile: FileId,
): Partial<Record<FileId, number[]>> {
  const map: Partial<Record<FileId, number[]>> = {};
  const regex = /LOCATION:\s*([^\n]+?):(\d+)/gi;
  const matches = text.matchAll(regex);

  for (const match of matches) {
    const rawPath = (match[1] || "").trim();
    const lineNo = Number(match[2]);
    if (!Number.isFinite(lineNo) || lineNo < 1) {
      continue;
    }
    const fileId = resolveFileId(rawPath) ?? fallbackFile;
    if (!map[fileId]) {
      map[fileId] = [];
    }
    if (!map[fileId]?.includes(lineNo)) {
      map[fileId]?.push(lineNo);
    }
  }

  return map;
}

function resolveFileId(path: string): FileId | null {
  const basename = path.split(/[\\/]/).pop()?.trim() ?? "";
  return KNOWN_FILE_IDS.includes(basename as FileId) ? (basename as FileId) : null;
}

function resolveAgentIndex(agent: string): number {
  const normalized = agent.toLowerCase();
  const numbered = normalized.match(/agent\s*([1-5])/);
  if (numbered) {
    const index = Number(numbered[1]) - 1;
    if (index >= 0 && index < AGENT_STEPS.length) {
      return index;
    }
  }
  return AGENT_STEPS.findIndex((step) => normalized.includes(step.toLowerCase()));
}

function findLineByNeedles(lines: string[], needles: string[]): number | null {
  for (let index = 0; index < lines.length; index += 1) {
    const line = lines[index].toLowerCase();
    if (needles.some((needle) => line.includes(needle.toLowerCase()))) {
      return index + 1;
    }
  }
  return null;
}

function withTrailingNewline(value: string): string {
  return value.endsWith("\n") ? value : `${value}\n`;
}

function asErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  return String(error);
}

function escapeHtml(value: string): string {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function highlightLine(line: string): string {
  TOKEN_PATTERN.lastIndex = 0;
  let html = "";
  let last = 0;
  let tokenMatch: RegExpExecArray | null = TOKEN_PATTERN.exec(line);

  while (tokenMatch) {
    const token = tokenMatch[0];
    const index = tokenMatch.index;
    html += escapeHtml(line.slice(last, index));

    if (tokenMatch[1]) {
      html += `<span class="tok-comment">${escapeHtml(token)}</span>`;
      last = index + token.length;
      break;
    } else if (tokenMatch[2]) {
      html += `<span class="tok-string">${escapeHtml(token)}</span>`;
    } else if (/^\d/.test(token)) {
      html += `<span class="tok-number">${escapeHtml(token)}</span>`;
    } else if (KEYWORDS.has(token)) {
      html += `<span class="tok-keyword">${escapeHtml(token)}</span>`;
    } else {
      html += `<span class="tok-function">${escapeHtml(token)}</span>`;
    }

    last = index + token.length;
    tokenMatch = TOKEN_PATTERN.exec(line);
  }

  html += escapeHtml(line.slice(last));
  return html.length > 0 ? html : "&nbsp;";
}

function renderCode(code: string, redLines: Set<number>): string {
  return code
    .split("\n")
    .map((line, index) => {
      const lineNo = index + 1;
      const isAlert = redLines.has(lineNo);
      return `<span class="code-line ${isAlert ? "code-line-alert" : ""}">
  <span class="line-no">${lineNo}</span>
  <span class="line-content">${highlightLine(line)}</span>
</span>`;
    })
    .join("");
}
